<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libsapling: /media/data/repositories/libsapling/include/libsapling/dm/graph.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="sapling.svg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libsapling
   &#160;<span id="projectnumber">0.5.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_b845477738e89c86cc7f6f4a03834131.html">libsapling</a></li><li class="navelem"><a class="el" href="dir_125f8c8195c7c9ec60fbde11d89eac57.html">dm</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">graph.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Graph implementation.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stddef.h&gt;</code><br />
<code>#include &lt;stdio.h&gt;</code><br />
<code>#include &quot;<a class="el" href="idiom_8h_source.html">libsapling/idiom.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="logic_8h_source.html">libsapling/dm/logic.h</a>&quot;</code><br />
</div>
<p><a href="graph_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinfo__stack.html">info_stack</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Means of passing user and implementation information between function calls.  <a href="structinfo__stack.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinfo__insert.html">info_insert</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aa0835d766910af9c7414d11774ad8487"><td class="memItemLeft" align="right" valign="top"><a id="aa0835d766910af9c7414d11774ad8487"></a>
typedef struct edge_storage *&#160;</td><td class="memItemRight" valign="bottom"><b>node_t</b></td></tr>
<tr class="separator:aa0835d766910af9c7414d11774ad8487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6be98da7fb6f356688ca6e4974d9f38d"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="graph_8h.html#a6be98da7fb6f356688ca6e4974d9f38d">predicate_fn</a>) (const node_t *ref, const struct <a class="el" href="structinfo__stack.html">info_stack</a> *info)</td></tr>
<tr class="memdesc:a6be98da7fb6f356688ca6e4974d9f38d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decides whether to run the apply function on an item. Behavior is modified by quantifiers.  <a href="graph_8h.html#a6be98da7fb6f356688ca6e4974d9f38d">More...</a><br /></td></tr>
<tr class="separator:a6be98da7fb6f356688ca6e4974d9f38d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5263355d886339d0f4b13f0c5f607cf8"><td class="memItemLeft" align="right" valign="top"><a id="a5263355d886339d0f4b13f0c5f607cf8"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="graph_8h.html#a5263355d886339d0f4b13f0c5f607cf8">apply_fn</a>) (node_t *ref, const struct <a class="el" href="structinfo__stack.html">info_stack</a> *info)</td></tr>
<tr class="memdesc:a5263355d886339d0f4b13f0c5f607cf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a user-defined operation on the node. <br /></td></tr>
<tr class="separator:a5263355d886339d0f4b13f0c5f607cf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a5a7b6234add5056a4a6b74da822019"><td class="memItemLeft" align="right" valign="top"><a id="a2a5a7b6234add5056a4a6b74da822019"></a>
typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="graph_8h.html#a2a5a7b6234add5056a4a6b74da822019">next_fn</a>) (node_t **ref, const struct <a class="el" href="structinfo__stack.html">info_stack</a> *info)</td></tr>
<tr class="memdesc:a2a5a7b6234add5056a4a6b74da822019"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chooses the next node to visit. <br /></td></tr>
<tr class="separator:a2a5a7b6234add5056a4a6b74da822019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a656ef1a53025dbe374a1d87ddf8c1c77"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="graph_8h.html#a656ef1a53025dbe374a1d87ddf8c1c77">edge_management_fn</a>) (node_t *ref, const node_t node, void *impl_ptr)</td></tr>
<tr class="memdesc:a656ef1a53025dbe374a1d87ddf8c1c77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called upon the insertion and deletion protocols.  <a href="graph_8h.html#a656ef1a53025dbe374a1d87ddf8c1c77">More...</a><br /></td></tr>
<tr class="separator:a656ef1a53025dbe374a1d87ddf8c1c77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a595058f2f07e082d0e134f6ee94f348f"><td class="memItemLeft" align="right" valign="top"><a id="a595058f2f07e082d0e134f6ee94f348f"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="graph_8h.html#a595058f2f07e082d0e134f6ee94f348f">fpfdata_fn</a>) (FILE *stream, const void *data)</td></tr>
<tr class="memdesc:a595058f2f07e082d0e134f6ee94f348f"><td class="mdescLeft">&#160;</td><td class="mdescRight">File print format data function prototype. <br /></td></tr>
<tr class="separator:a595058f2f07e082d0e134f6ee94f348f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5904dbbe6dbd821a312f9a93456149fc"><td class="memItemLeft" align="right" valign="top"><a id="a5904dbbe6dbd821a312f9a93456149fc"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="graph_8h.html#a5904dbbe6dbd821a312f9a93456149fc">fpfnode_fn</a>) (FILE *stream, const node_t node, <a class="el" href="graph_8h.html#a595058f2f07e082d0e134f6ee94f348f">fpfdata_fn</a> fpfdata)</td></tr>
<tr class="memdesc:a5904dbbe6dbd821a312f9a93456149fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">File print format node function prototype. <br /></td></tr>
<tr class="separator:a5904dbbe6dbd821a312f9a93456149fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ad9ac5c4bdc096a44dee91d0eee5127"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="graph_8h.html#a1ad9ac5c4bdc096a44dee91d0eee5127">all_access_adapter_fn</a>) (node_t *ref, void *info, <a class="el" href="graph_8h.html#a5263355d886339d0f4b13f0c5f607cf8">apply_fn</a> apply)</td></tr>
<tr class="memdesc:a1ad9ac5c4bdc096a44dee91d0eee5127"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic access all nodes adapter function prototype.  <a href="graph_8h.html#a1ad9ac5c4bdc096a44dee91d0eee5127">More...</a><br /></td></tr>
<tr class="separator:a1ad9ac5c4bdc096a44dee91d0eee5127"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af988562ba72e65f0bca41a8cfae50e90"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="graph_8h.html#af988562ba72e65f0bca41a8cfae50e90">predicate_0</a> (<a class="el" href="idiom_8h.html#addf5ec070e9499d36b7f2009ce736076">UNUSED</a> const node_t *ref, <a class="el" href="idiom_8h.html#addf5ec070e9499d36b7f2009ce736076">UNUSED</a> const struct <a class="el" href="structinfo__stack.html">info_stack</a> *info)</td></tr>
<tr class="memdesc:af988562ba72e65f0bca41a8cfae50e90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trivial predicate function that always returns 0.  <a href="graph_8h.html#af988562ba72e65f0bca41a8cfae50e90">More...</a><br /></td></tr>
<tr class="separator:af988562ba72e65f0bca41a8cfae50e90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa75b02c243a3be0c0e34722a93a269d9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="graph_8h.html#aa75b02c243a3be0c0e34722a93a269d9">predicate_1</a> (<a class="el" href="idiom_8h.html#addf5ec070e9499d36b7f2009ce736076">UNUSED</a> const node_t *ref, <a class="el" href="idiom_8h.html#addf5ec070e9499d36b7f2009ce736076">UNUSED</a> const struct <a class="el" href="structinfo__stack.html">info_stack</a> *info)</td></tr>
<tr class="memdesc:aa75b02c243a3be0c0e34722a93a269d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trivial predicate function that always returns 1.  <a href="graph_8h.html#aa75b02c243a3be0c0e34722a93a269d9">More...</a><br /></td></tr>
<tr class="separator:aa75b02c243a3be0c0e34722a93a269d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87802e38dccd8951510aebc205fabf01"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="graph_8h.html#a87802e38dccd8951510aebc205fabf01">graph__data</a> (const node_t node, size_t edge_storage)</td></tr>
<tr class="memdesc:a87802e38dccd8951510aebc205fabf01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the data storage of a node.  <a href="graph_8h.html#a87802e38dccd8951510aebc205fabf01">More...</a><br /></td></tr>
<tr class="separator:a87802e38dccd8951510aebc205fabf01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c6438f3ea9ac2cbe971133465510e85"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="graph_8h.html#a7c6438f3ea9ac2cbe971133465510e85">graph__access</a> (enum <a class="el" href="logic_8h.html#a92452e3188bb558c8ed61df7c58e5d40">qt</a> <a class="el" href="logic_8h.html#a92452e3188bb558c8ed61df7c58e5d40">qt</a>, node_t *ref, const struct <a class="el" href="structinfo__stack.html">info_stack</a> *info, <a class="el" href="graph_8h.html#a6be98da7fb6f356688ca6e4974d9f38d">predicate_fn</a> predicate, <a class="el" href="graph_8h.html#a5263355d886339d0f4b13f0c5f607cf8">apply_fn</a> apply, <a class="el" href="graph_8h.html#a2a5a7b6234add5056a4a6b74da822019">next_fn</a> next)</td></tr>
<tr class="memdesc:a7c6438f3ea9ac2cbe971133465510e85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access protocol. Traverses the graph according to a quantifier modifier and specific implementation workings.  <a href="graph_8h.html#a7c6438f3ea9ac2cbe971133465510e85">More...</a><br /></td></tr>
<tr class="separator:a7c6438f3ea9ac2cbe971133465510e85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7d276174af446e8a781db2a1ceb38f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="graph_8h.html#af7d276174af446e8a781db2a1ceb38f0">graph__insert</a> (node_t *ref, const struct <a class="el" href="structinfo__stack.html">info_stack</a> *info, <a class="el" href="graph_8h.html#a656ef1a53025dbe374a1d87ddf8c1c77">edge_management_fn</a> edge_management, size_t edge_storage)</td></tr>
<tr class="memdesc:af7d276174af446e8a781db2a1ceb38f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insertion protocol.  <a href="graph_8h.html#af7d276174af446e8a781db2a1ceb38f0">More...</a><br /></td></tr>
<tr class="separator:af7d276174af446e8a781db2a1ceb38f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eac1a9414488e56aa3bf34c05f5129f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="graph_8h.html#a8eac1a9414488e56aa3bf34c05f5129f">graph__delete</a> (node_t *ref, const struct <a class="el" href="structinfo__stack.html">info_stack</a> *info, <a class="el" href="graph_8h.html#a656ef1a53025dbe374a1d87ddf8c1c77">edge_management_fn</a> edge_management)</td></tr>
<tr class="memdesc:a8eac1a9414488e56aa3bf34c05f5129f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletion protocol.  <a href="graph_8h.html#a8eac1a9414488e56aa3bf34c05f5129f">More...</a><br /></td></tr>
<tr class="separator:a8eac1a9414488e56aa3bf34c05f5129f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41cea0ceed6e5ca41a892b82dfb191de"><td class="memItemLeft" align="right" valign="top"><a id="a41cea0ceed6e5ca41a892b82dfb191de"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="graph_8h.html#a41cea0ceed6e5ca41a892b82dfb191de">graph__print_data</a> (FILE *stream, node_t *ref, <a class="el" href="graph_8h.html#a1ad9ac5c4bdc096a44dee91d0eee5127">all_access_adapter_fn</a> access_adapter, <a class="el" href="graph_8h.html#a5904dbbe6dbd821a312f9a93456149fc">fpfnode_fn</a> fpfnode, <a class="el" href="graph_8h.html#a595058f2f07e082d0e134f6ee94f348f">fpfdata_fn</a> fpfdata)</td></tr>
<tr class="memdesc:a41cea0ceed6e5ca41a892b82dfb191de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints all the data contained in the set. <br /></td></tr>
<tr class="separator:a41cea0ceed6e5ca41a892b82dfb191de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3ab5759421103552bb35da6d26ba468"><td class="memItemLeft" align="right" valign="top"><a id="aa3ab5759421103552bb35da6d26ba468"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="graph_8h.html#aa3ab5759421103552bb35da6d26ba468">graph__dump_dot</a> (FILE *stream, node_t *ref, <a class="el" href="graph_8h.html#a1ad9ac5c4bdc096a44dee91d0eee5127">all_access_adapter_fn</a> access_adapter, <a class="el" href="graph_8h.html#a5904dbbe6dbd821a312f9a93456149fc">fpfnode_fn</a> fpfnode, <a class="el" href="graph_8h.html#a595058f2f07e082d0e134f6ee94f348f">fpfdata_fn</a> fpfdata)</td></tr>
<tr class="memdesc:aa3ab5759421103552bb35da6d26ba468"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dumps the graph in the DOT graph description language. <br /></td></tr>
<tr class="separator:aa3ab5759421103552bb35da6d26ba468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52a3e28033894da59eabdfbb96d63b6d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="graph_8h.html#a52a3e28033894da59eabdfbb96d63b6d">graph__length</a> (node_t *ref, <a class="el" href="graph_8h.html#a1ad9ac5c4bdc096a44dee91d0eee5127">all_access_adapter_fn</a> access_adapter)</td></tr>
<tr class="memdesc:a52a3e28033894da59eabdfbb96d63b6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of items contained in the set.  <a href="graph_8h.html#a52a3e28033894da59eabdfbb96d63b6d">More...</a><br /></td></tr>
<tr class="separator:a52a3e28033894da59eabdfbb96d63b6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Graph implementation. </p>
<p>This implementation serves as the basis for implementing other dynamic data structures (DDS). The general idea behind this implementation is to represent a set using a graph, taking advantage of the graph's structure to speed up operations, like all data structures aim to do. The hope is that someday it will be possible to automatically determine and implement an optimal graph structure for a set only by analyzing its actual usage in a program and using this implementation as the basis. For now it serves as an abstraction to implement them manually. Implementation for binary set operations is currently neither provided nor the focus, instead the focus of this implementation lies in providing first-order logic data manipulation. For this purpose it provides three elemental operations: insertion, deletion and access, the two latter accepting first-order logic quantifiers, since they manipulate what is already in the set. Insertion is regarded as being existentially quantified, since it searches for the most appropiate location in the graph's structure where a new node must be appended to the overall graph, perhaps according to some attribute of the data to be inserted in the set. Aside from that, some convenience and debugging functions are also provided.</p>
<p>Inspired by the implementation of the C style null-terminated string, which defines a string as a pointer to the first character, this implementation defines a graph as an edge (pointer) to a starting node. Whereas in a string the next character can be accessed by incrementing the pointer by the size of a character, in this graph implementation each node stores the edges that sprout from it to other nodes, referred to as the <b>edge storage</b> of the node. This may be a just an edge to the next node, or several of them, even edge management information such as the balance factor of an AVL node, which is not an edge in itself, it may be a dynamic number of edges with the number of edges stored at the beginning of the storage, it may be another dynamic data structure (another graph), which may store attributed edges sorted by that attribute... In conclusion: as long as the particular implementations can interpret the contents of this storage anything goes.</p>
<p>The edge storage may be followed by a <b>data storage</b>, which combined account for the whole contiguous block of memory allocated at the node's address. Like with the edge storage, anything can go in the data storage as long as the user can interpret the contents. Edge management data must no be mixed with the data storage, edge management information need not be edges exclusively. Particular implementations may, however, appropiate the data storage away from the user, and impose their own interfaces to interact with the data if the use case warrants it. For example, in a lexer graph, accepting states might store an identifier of a terminal class as a pointer to an integer, and decide that a state is not an accepting state if the value of that pointer is NULL.</p>
<p>An important thing to keep in mind is that all defined operations and function prototypes actually accept an edge (pointer) that leads to the node, rather than the node itself, as this simplifies the implementation of insertion and deletion. For example, upon deleting an AVL node with only one child it is sufficient to promote the child to the parent's position by dereferencing the edge and replacing the parent node's address with that of the child. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a1ad9ac5c4bdc096a44dee91d0eee5127"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ad9ac5c4bdc096a44dee91d0eee5127">&#9670;&nbsp;</a></span>all_access_adapter_fn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* all_access_adapter_fn) (node_t *ref, void *info, <a class="el" href="graph_8h.html#a5263355d886339d0f4b13f0c5f607cf8">apply_fn</a> apply)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generic access all nodes adapter function prototype. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Originally created for use with the generic graph printing functions which invokes the particular DDS' implementation's access function without having to know the implementation of the next function. </dd></dl>

</div>
</div>
<a id="a656ef1a53025dbe374a1d87ddf8c1c77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a656ef1a53025dbe374a1d87ddf8c1c77">&#9670;&nbsp;</a></span>edge_management_fn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* edge_management_fn) (node_t *ref, const node_t node, void *impl_ptr)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called upon the insertion and deletion protocols. </p>
<p>On insertion <code>node</code> contains the address of the newly created node and <code>ref</code> the position in the graph where it was determined for it to be inserted, so usually edge management functions should assign <code>*ref = node</code> at some point. This is however, not enforced with any language construct to account for the case of the AVL tree rotations, where instead of the newly created node being directly appended to the graph at <code>ref</code>, it may become a child of its child and the former child is instead appended at <code>ref</code>.</p>
<p>On deletion <code>node</code> is the same as <code>*ref</code>. Likewise it takes care of restructuring the graph at <code>ref</code> upon deleting a node.</p>
<p>It also may perform the task of initializing the data of the edge storage.</p>
<dl class="section attention"><dt>Attention</dt><dd>The insertion and deletion protocols take care of allocating and freeing the <code>node</code>, so that task must not be performed within the edge management function. </dd></dl>

</div>
</div>
<a id="a6be98da7fb6f356688ca6e4974d9f38d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6be98da7fb6f356688ca6e4974d9f38d">&#9670;&nbsp;</a></span>predicate_fn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* predicate_fn) (const node_t *ref, const struct <a class="el" href="structinfo__stack.html">info_stack</a> *info)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decides whether to run the apply function on an item. Behavior is modified by quantifiers. </p>
<p>When modified with universal quantification the predicate decides whether to run the apply function on the current node.</p>
<p>When modified with existential quantification if the predicate is satisfied then the apply function is run on the current node and the traversal ends. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a7c6438f3ea9ac2cbe971133465510e85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c6438f3ea9ac2cbe971133465510e85">&#9670;&nbsp;</a></span>graph__access()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void graph__access </td>
          <td>(</td>
          <td class="paramtype">enum <a class="el" href="logic_8h.html#a92452e3188bb558c8ed61df7c58e5d40">qt</a>&#160;</td>
          <td class="paramname"><em>qt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_t *&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structinfo__stack.html">info_stack</a> *&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="graph_8h.html#a6be98da7fb6f356688ca6e4974d9f38d">predicate_fn</a>&#160;</td>
          <td class="paramname"><em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="graph_8h.html#a5263355d886339d0f4b13f0c5f607cf8">apply_fn</a>&#160;</td>
          <td class="paramname"><em>apply</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="graph_8h.html#a2a5a7b6234add5056a4a6b74da822019">next_fn</a>&#160;</td>
          <td class="paramname"><em>next</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access protocol. Traverses the graph according to a quantifier modifier and specific implementation workings. </p>
<p>Visits all the reachable nodes starting from the specified node. Equivalent to traversal and associated with the universal quantifier.</p>
<p>Visits the minimum number of nodes in the graph until reaching a target node. Equivalent to search and associated with the existential quantifier. </p>

</div>
</div>
<a id="a87802e38dccd8951510aebc205fabf01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87802e38dccd8951510aebc205fabf01">&#9670;&nbsp;</a></span>graph__data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* graph__data </td>
          <td>(</td>
          <td class="paramtype">const node_t&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>edge_storage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pointer to the data storage of a node. </p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the data storage of a node. </dd></dl>

</div>
</div>
<a id="a8eac1a9414488e56aa3bf34c05f5129f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8eac1a9414488e56aa3bf34c05f5129f">&#9670;&nbsp;</a></span>graph__delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void graph__delete </td>
          <td>(</td>
          <td class="paramtype">node_t *&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structinfo__stack.html">info_stack</a> *&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="graph_8h.html#a656ef1a53025dbe374a1d87ddf8c1c77">edge_management_fn</a>&#160;</td>
          <td class="paramname"><em>edge_management</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletion protocol. </p>
<dl class="section attention"><dt>Attention</dt><dd>Deleting a node will also deallocate the memory previously allocated for its data so make sure to keep track of dangling pointers to data storage. </dd></dl>

</div>
</div>
<a id="af7d276174af446e8a781db2a1ceb38f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7d276174af446e8a781db2a1ceb38f0">&#9670;&nbsp;</a></span>graph__insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void graph__insert </td>
          <td>(</td>
          <td class="paramtype">node_t *&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structinfo__stack.html">info_stack</a> *&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="graph_8h.html#a656ef1a53025dbe374a1d87ddf8c1c77">edge_management_fn</a>&#160;</td>
          <td class="paramname"><em>edge_management</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>edge_storage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insertion protocol. </p>
<dl class="section attention"><dt>Attention</dt><dd>The protocol expects the contents of the user information of the <a class="el" href="structinfo__stack.html">info_stack</a> to be a <code>size_t</code> indicating the size of the data followed by that number of bytes of data. That size will be allocated for the data storage of the node and the data copied over as is. Extra information may follow. </dd></dl>

</div>
</div>
<a id="a52a3e28033894da59eabdfbb96d63b6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52a3e28033894da59eabdfbb96d63b6d">&#9670;&nbsp;</a></span>graph__length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int graph__length </td>
          <td>(</td>
          <td class="paramtype">node_t *&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="graph_8h.html#a1ad9ac5c4bdc096a44dee91d0eee5127">all_access_adapter_fn</a>&#160;</td>
          <td class="paramname"><em>access_adapter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of items contained in the set. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of items contained in the set. </dd></dl>

</div>
</div>
<a id="af988562ba72e65f0bca41a8cfae50e90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af988562ba72e65f0bca41a8cfae50e90">&#9670;&nbsp;</a></span>predicate_0()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int predicate_0 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="idiom_8h.html#addf5ec070e9499d36b7f2009ce736076">UNUSED</a> const node_t *&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="idiom_8h.html#addf5ec070e9499d36b7f2009ce736076">UNUSED</a> const struct <a class="el" href="structinfo__stack.html">info_stack</a> *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trivial predicate function that always returns 0. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa75b02c243a3be0c0e34722a93a269d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa75b02c243a3be0c0e34722a93a269d9">&#9670;&nbsp;</a></span>predicate_1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int predicate_1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="idiom_8h.html#addf5ec070e9499d36b7f2009ce736076">UNUSED</a> const node_t *&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="idiom_8h.html#addf5ec070e9499d36b7f2009ce736076">UNUSED</a> const struct <a class="el" href="structinfo__stack.html">info_stack</a> *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trivial predicate function that always returns 1. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
